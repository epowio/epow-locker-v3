{
  "language": "Solidity",
  "sources": {
    "contracts/EPOWLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * EPOWLocker\r\n * - Escrows Uniswap V3 LP position NFTs (ERC-721 from NonfungiblePositionManager) until a timestamp.\r\n * - No owner backdoors. Only the designated beneficiary can withdraw after unlock.\r\n * - Optional fee collection while locked (to beneficiary or a custom feesRecipient).\r\n * - Supports lock via prior approve() OR gasless lockWithPermit().\r\n * - Rejects unsolicited NFT transfers using a strict ERC721Receiver gate.\r\n */\r\ninterface INonfungiblePositionManager {\r\n    // ERC-721\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    // Permit (gasless approval)\r\n    function permit(\r\n        address spender,\r\n        uint256 tokenId,\r\n        uint256 deadline,\r\n        uint8 v, bytes32 r, bytes32 s\r\n    ) external;\r\n\r\n    // Fee collection\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n    function collect(CollectParams calldata params)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4);\r\n}\r\n\r\ncontract EPOWLocker is IERC721Receiver {\r\n    uint256 private _status;\r\n    modifier nonReentrant() {\r\n        require(_status != 2, \"REENTRANCY\");\r\n        _status = 2;\r\n        _;\r\n        _status = 1;\r\n    }\r\n\r\n    struct Lock {\r\n        address depositor;        // original owner that initiated the lock\r\n        address beneficiary;      // who can withdraw after unlock\r\n        address feesRecipient;    // who receives collected fees during lock \r\n        uint64  unlockTime;       // unix seconds\r\n        bool    active;           // true while held\r\n    }\r\n\r\n    // ---- State ----\r\n    INonfungiblePositionManager public immutable posm;\r\n    mapping(uint256 => Lock) public locks;          // tokenId => Lock\r\n    mapping(uint256 => bool)  private _expecting;   // tokenId => expect inbound transfer gate\r\n\r\n    // ---- Events ----\r\n    event Locked(uint256 indexed tokenId, address indexed depositor, address indexed beneficiary, uint64 unlockTime);\r\n    event Extended(uint256 indexed tokenId, uint64 oldUnlock, uint64 newUnlock);\r\n    event FeesRecipientSet(uint256 indexed tokenId, address indexed oldRecipient, address indexed newRecipient);\r\n    event FeesCollected(uint256 indexed tokenId, address indexed to, uint256 amount0, uint256 amount1);\r\n    event Withdrawn(uint256 indexed tokenId, address to);\r\n\r\n    // ---- Errors ----\r\n    error NotOwner();\r\n    error NotActive();\r\n    error AlreadyActive();\r\n    error NotApproved();\r\n    error InvalidTime();\r\n    error TooSoon();\r\n    error NotPOSM();\r\n    error UnexpectedToken();\r\n\r\n    constructor(address _posm) {\r\n        require(_posm != address(0), \"POSM_ZERO\");\r\n        posm = INonfungiblePositionManager(_posm);\r\n        _status = 1;\r\n    }\r\n\r\n    // ------------------------------------------------------------\r\n    // Core: lock via prior approve()\r\n    // ------------------------------------------------------------\r\n    function lock(uint256 tokenId, address beneficiary, uint64 unlockTime) external nonReentrant {\r\n        if (unlockTime <= block.timestamp) revert InvalidTime();\r\n        if (posm.ownerOf(tokenId) != msg.sender) revert NotOwner();\r\n        if (locks[tokenId].active) revert AlreadyActive();\r\n        if (posm.getApproved(tokenId) != address(this)) revert NotApproved();\r\n\r\n        // Mark that we expect this incoming transfer from POSM\r\n        _expecting[tokenId] = true;\r\n        posm.safeTransferFrom(msg.sender, address(this), tokenId);\r\n\r\n        // Record lock terms\r\n        locks[tokenId] = Lock({\r\n            depositor: msg.sender,\r\n            beneficiary: beneficiary,\r\n            feesRecipient: beneficiary,\r\n            unlockTime: unlockTime,\r\n            active: true\r\n        });\r\n\r\n        emit Locked(tokenId, msg.sender, beneficiary, unlockTime);\r\n    }\r\n\r\n    // ------------------------------------------------------------\r\n    // Core: lock with EIP-2612-like permit for POSM (gasless approval path)\r\n    // ------------------------------------------------------------\r\n    function lockWithPermit(\r\n        uint256 tokenId,\r\n        address beneficiary,\r\n        uint64 unlockTime,\r\n        uint256 permitDeadline,\r\n        uint8 v, bytes32 r, bytes32 s\r\n    ) external nonReentrant {\r\n        if (unlockTime <= block.timestamp) revert InvalidTime();\r\n        if (locks[tokenId].active) revert AlreadyActive();\r\n\r\n        // Permit this contract to transfer the NFT\r\n        posm.permit(address(this), tokenId, permitDeadline, v, r, s);\r\n\r\n        // Verify ownership and approval then pull\r\n        address owner = posm.ownerOf(tokenId);\r\n        // The caller must be the owner for clear intent\r\n        if (owner != msg.sender) revert NotOwner();\r\n\r\n        _expecting[tokenId] = true;\r\n        posm.safeTransferFrom(owner, address(this), tokenId);\r\n\r\n        locks[tokenId] = Lock({\r\n            depositor: owner,\r\n            beneficiary: beneficiary,\r\n            feesRecipient: beneficiary,\r\n            unlockTime: unlockTime,\r\n            active: true\r\n        });\r\n\r\n        emit Locked(tokenId, owner, beneficiary, unlockTime);\r\n    }\r\n\r\n    // ------------------------------------------------------------\r\n    // Manage lock\r\n    // ------------------------------------------------------------\r\n    function extendLock(uint256 tokenId, uint64 newUnlockTime) external {\r\n        Lock storage L = locks[tokenId];\r\n        if (!L.active) revert NotActive();\r\n        if (msg.sender != L.depositor) revert NotOwner();\r\n        if (newUnlockTime <= L.unlockTime) revert InvalidTime();\r\n\r\n        uint64 old = L.unlockTime;\r\n        L.unlockTime = newUnlockTime;\r\n        emit Extended(tokenId, old, newUnlockTime);\r\n    }\r\n\r\n    function setFeesRecipient(uint256 tokenId, address newRecipient) external {\r\n        Lock storage L = locks[tokenId];\r\n        if (!L.active) revert NotActive();\r\n        // Allow depositor OR beneficiary to set; choose your policy\r\n        if (msg.sender != L.depositor && msg.sender != L.beneficiary) revert NotOwner();\r\n\r\n        address old = L.feesRecipient;\r\n        L.feesRecipient = newRecipient;\r\n        emit FeesRecipientSet(tokenId, old, newRecipient);\r\n    }\r\n\r\n    // ------------------------------------------------------------\r\n    // Fee collection while locked\r\n    // ------------------------------------------------------------\r\n    function collectFees(uint256 tokenId) external nonReentrant returns (uint256 amount0, uint256 amount1) {\r\n        Lock storage L = locks[tokenId];\r\n        if (!L.active) revert NotActive();\r\n\r\n        (amount0, amount1) = posm.collect(\r\n            INonfungiblePositionManager.CollectParams({\r\n                tokenId: tokenId,\r\n                recipient: L.feesRecipient,\r\n                amount0Max: type(uint128).max,\r\n                amount1Max: type(uint128).max\r\n            })\r\n        );\r\n\r\n        emit FeesCollected(tokenId, L.feesRecipient, amount0, amount1);\r\n    }\r\n\r\n    // ------------------------------------------------------------\r\n    // Withdraw after unlock\r\n    // ------------------------------------------------------------\r\n    function withdraw(uint256 tokenId, address to) external nonReentrant {\r\n        Lock storage L = locks[tokenId];\r\n        if (!L.active) revert NotActive();\r\n        if (block.timestamp < L.unlockTime) revert TooSoon();\r\n        if (msg.sender != L.beneficiary) revert NotOwner();\r\n\r\n        L.active = false; // Effects first\r\n        posm.safeTransferFrom(address(this), to, tokenId); // Interaction\r\n        emit Withdrawn(tokenId, to);\r\n    }\r\n\r\n    // ------------------------------------------------------------\r\n    // Views\r\n    // ------------------------------------------------------------\r\n    function isLocked(uint256 tokenId) external view returns (bool active, uint64 unlockTime, address beneficiary) {\r\n        Lock storage L = locks[tokenId];\r\n        return (L.active, L.unlockTime, L.beneficiary);\r\n    }\r\n\r\n    // ------------------------------------------------------------\r\n    // ERC721 Receiver gate: accept only expected inbound from POSM\r\n    // ------------------------------------------------------------\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256 tokenId,\r\n        bytes calldata\r\n    ) external override returns (bytes4) {\r\n        if (msg.sender != address(posm)) revert NotPOSM();\r\n        if (!_expecting[tokenId]) revert UnexpectedToken();\r\n        // Clear the expectation flag; lock() already recorded details after transfer\r\n        delete _expecting[tokenId];\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}